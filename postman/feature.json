{
	"info": {
		"_postman_id": "96b70a3c-3e17-4758-b6cc-b5a9ed0edfa4",
		"name": "_Feature Comments",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "23412761"
	},
	"item": [
		{
			"name": "Correct Functionality",
			"item": [
				{
					"name": "Get comments of Event",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        await api.publishParticipationRequest(event.id, participantUser.id);\r",
									"        api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"        await new Promise(resolve => setTimeout(resolve, 1000));\r",
									"        api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"        await new Promise(resolve => setTimeout(resolve, 1000));\r",
									"        comment = await api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
									"    pm.response.to.be.ok;    \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target[0]).to.have.property('id');\r",
									"    pm.expect(target[0]).to.have.property('text');\r",
									"    pm.expect(target[0]).to.have.property('author');\r",
									"    pm.expect(target[0]).to.have.property('createdOn');\r",
									"    pm.expect(target[0]).to.have.property('modifiedOn');\r",
									"});\r",
									"\r",
									"pm.test(\"Should find correct number of comments\", function () {\r",
									"    pm.expect(target.length).to.eql(3);\r",
									"});\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    let comment = pm.collectionVariables.get(\"comment\");\r",
									"    pm.expect(target[0].id).equal(comment.id);\r",
									"    pm.expect(target[0].text).equal(comment.text);\r",
									"    pm.expect(target[0].author.id).equal(comment.author.id);\r",
									"    pm.expect(target[0].createdOn).equal(comment.createdOn);  \r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/events/{{eid}}/comments?from&size",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"events",
								"{{eid}}",
								"comments"
							],
							"query": [
								{
									"key": "from",
									"value": null
								},
								{
									"key": "size",
									"value": null
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Change comment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        await api.publishParticipationRequest(event.id, participantUser.id);\r",
									"        comment = await rnd.getComment(event.id, participantUser.id);\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"\r",
									"        pm.request.body.update({\r",
									"                mode: 'raw',\r",
									"                raw: JSON.stringify(comment),\r",
									"                options: { raw: { language: 'json' } \r",
									"            }\r",
									"        });\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 201 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(201);  \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"const source = JSON.parse(pm.request.body.raw);\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('id');\r",
									"    pm.expect(target).to.have.property('text');\r",
									"    pm.expect(target).to.have.property('author');\r",
									"    pm.expect(target).to.have.property('createdOn');\r",
									"    pm.expect(target).to.have.property('modifiedOn');\r",
									"});\r",
									"\r",
									"const rnd = new RandomUtils();\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.text).equal(source.text);\r",
									"    pm.expect(target.createdOn).equal(rnd.getFutureDateTime(0,0,0));\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete comment Public",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        await api.publishParticipationRequest(event.id, participantUser.id);\r",
									"        comment = await api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"cid\", comment.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 204\", function () {\r",
									"    pm.response.to.have.status(204);\r",
									"});\r",
									"const source = pm.collectionVariables.get('comment');\r",
									"const userId = pm.collectionVariables.get('uid');\r",
									"\r",
									"let body;\r",
									"const reqPostDelete = {\r",
									"                url: \"http://localhost:8080/events/\" + pm.collectionVariables.get(\"eid\") + \"/comments\",\r",
									"                method: \"GET\",\r",
									"                body: body == null ? \"\" : JSON.stringify(body),\r",
									"                header: { \"Content-Type\": \"application/json\" },\r",
									"            };\r",
									"pm.sendRequest(reqPostDelete, (error, response) => {\r",
									"    pm.test(\"Пользователь должен быть удалён после выполнения запроса\", function(){\r",
									"        pm.expect(response.json().length).to.eql(0);\r",
									"    });\r",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments/{{cid}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments",
								"{{cid}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete comment Admin",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        await api.publishParticipationRequest(event.id, participantUser.id);\r",
									"        comment = await api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"cid\", comment.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 204\", function () {\r",
									"    pm.response.to.have.status(204);\r",
									"});\r",
									"const source = pm.collectionVariables.get('comment');\r",
									"const userId = pm.collectionVariables.get('uid');\r",
									"\r",
									"let body;\r",
									"const reqPostDelete = {\r",
									"                url: \"http://localhost:8080/events/\" + pm.collectionVariables.get(\"eid\") + \"/comments\",\r",
									"                method: \"GET\",\r",
									"                body: body == null ? \"\" : JSON.stringify(body),\r",
									"                header: { \"Content-Type\": \"application/json\" },\r",
									"            };\r",
									"pm.sendRequest(reqPostDelete, (error, response) => {\r",
									"    pm.test(\"Пользователь должен быть удалён после выполнения запроса\", function(){\r",
									"        pm.expect(response.json().length).to.eql(0);\r",
									"    });\r",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/admin/comments/{{cid}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"admin",
								"comments",
								"{{cid}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Change comment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let newComment;\r",
									"    let initialComment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        await api.publishParticipationRequest(event.id, participantUser.id);\r",
									"        comment = await api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"        newComment = rnd.getComment(event.id, participantUser.id);\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"cid\", comment.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"    \r",
									"    pm.request.body.update({\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify(newComment),\r",
									"        options: { raw: { language: 'json' } }\r",
									"    });\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 200 и данные в формате json\", function () {\r",
									"    pm.response.to.be.ok;    \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"const source = pm.collectionVariables.get(\"comment\");\r",
									"const requestBody = JSON.parse(pm.request.body.raw);\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('id');\r",
									"    pm.expect(target).to.have.property('text');\r",
									"    pm.expect(target).to.have.property('author');\r",
									"    pm.expect(target).to.have.property('createdOn');\r",
									"    pm.expect(target).to.have.property('modifiedOn');\r",
									"    pm.expect(target).to.have.property('event');\r",
									"});\r",
									"\r",
									"const rnd = new RandomUtils();\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.text).equal(requestBody.text);\r",
									"    pm.expect(target.modifiedOn).equal(rnd.getFutureDateTime(0,0,0));\r",
									"    pm.expect(target.createdOn).equal(source.createdOn);\r",
									"    pm.expect(target.id).equal(source.id);\r",
									"    pm.expect(target.createdOn).equal(source.createdOn);\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments/{{cid}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments",
								"{{cid}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Comments Fail",
			"item": [
				{
					"name": "Add comment to Event Fail not published",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
									"        comment = rnd.getComment(event.id, user.id);\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", user.id);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"    \r",
									"    pm.request.body.update({\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify(comment),\r",
									"        options: { raw: { language: 'json' } }\r",
									"    });\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 404 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(404);  \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('status');\r",
									"    pm.expect(target).to.have.property('reason');\r",
									"    pm.expect(target).to.have.property('message');\r",
									"    pm.expect(target).to.have.property('timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.message).to.contain(\"is not published\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add comment to Event Fail not confirmed user",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        comment = await rnd.getComment(event.id, participantUser.id);\r",
									"        \r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"    \r",
									"    pm.request.body.update({\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify(comment),\r",
									"        options: { raw: { language: 'json' } }\r",
									"    });\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 404 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(409);  \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('status');\r",
									"    pm.expect(target).to.have.property('reason');\r",
									"    pm.expect(target).to.have.property('message');\r",
									"    pm.expect(target).to.have.property('timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.message).to.contain(\"not confirmed to participate\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add comment to Event Fail empty text",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
									"        comment = rnd.getComment(event.id, user.id);\r",
									"        event = await api.publishEvent(event.id);\r",
									"\r",
									"        comment.text = \"\";\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", user.id);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"    \r",
									"    pm.request.body.update({\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify(comment),\r",
									"        options: { raw: { language: 'json' } }\r",
									"    });\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(400);  \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('status');\r",
									"    pm.expect(target).to.have.property('reason');\r",
									"    pm.expect(target).to.have.property('message');\r",
									"    pm.expect(target).to.have.property('timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.message).to.contain(\"Validation failed\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add comment to Event Fail text too big",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let comment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = await api.addEvent(user.id, rnd.getEvent(category.id));\r",
									"        comment = rnd.getComment(event.id, user.id);\r",
									"        event = await api.publishEvent(event.id);\r",
									"\r",
									"        comment.text = \"Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. Too big Text. \";\r",
									"\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"uid\", user.id);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"    \r",
									"    pm.request.body.update({\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify(comment),\r",
									"        options: { raw: { language: 'json' } }\r",
									"    });\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(400);  \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('status');\r",
									"    pm.expect(target).to.have.property('reason');\r",
									"    pm.expect(target).to.have.property('message');\r",
									"    pm.expect(target).to.have.property('timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.message).to.contain(\"Validation failed\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments"
							]
						}
					},
					"response": []
				},
				{
					"name": "Change comment Fail Body",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const main = async () => {\r",
									"    const api = new API(pm);\r",
									"    const rnd = new RandomUtils();\r",
									"\r",
									"    let newComment;\r",
									"    let initialComment;\r",
									"    try {\r",
									"        const user = await api.addUser(rnd.getUser());\r",
									"        const category = await api.addCategory(rnd.getCategory());\r",
									"        let event = rnd.getEvent(category.id);\r",
									"        event.requestModeration = 'false';\r",
									"        event = await api.addEvent(user.id, event);\r",
									"        event = await api.publishEvent(event.id);\r",
									"        const participantUser = await api.addUser(rnd.getUser());\r",
									"        await api.publishParticipationRequest(event.id, participantUser.id);\r",
									"        comment = await api.addComment(participantUser.id, event.id, rnd.getComment(event.id, participantUser.id));\r",
									"        newComment = rnd.getComment(event.id, participantUser.id);\r",
									"        newComment.text = \"\";\r",
									"        pm.collectionVariables.set(\"uid\", participantUser.id);\r",
									"        pm.collectionVariables.set(\"eid\", event.id);\r",
									"        pm.collectionVariables.set(\"cid\", comment.id);\r",
									"        pm.collectionVariables.set(\"comment\", comment);\r",
									"    } catch(err) {\r",
									"        console.error(\"Ошибка при подготовке тестовых данных.\", err);\r",
									"    }\r",
									"    \r",
									"    pm.request.body.update({\r",
									"        mode: 'raw',\r",
									"        raw: JSON.stringify(newComment),\r",
									"        options: { raw: { language: 'json' } }\r",
									"    });\r",
									"};\r",
									"\r",
									"const interval = setInterval(() => {}, 1000);\r",
									"\r",
									"setTimeout(async () => \r",
									"    {\r",
									"        try {\r",
									"            // выполняем наш скрипт\r",
									"            await main();\r",
									"        } catch (e) {\r",
									"            console.error(e);\r",
									"        } finally {\r",
									"            clearInterval(interval);\r",
									"        }\r",
									"    },  \r",
									"    100 \r",
									");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Ответ должен содержать код статуса 400 и данные в формате json\", function () {\r",
									"    pm.response.to.have.status(400);  \r",
									"    pm.response.to.be.withBody;\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"\r",
									"const target = pm.response.json();\r",
									"\r",
									"pm.test(\"Should contain requiered fields\", function () {\r",
									"    pm.expect(target).to.have.property('status');\r",
									"    pm.expect(target).to.have.property('reason');\r",
									"    pm.expect(target).to.have.property('message');\r",
									"    pm.expect(target).to.have.property('timestamp');\r",
									"});\r",
									"\r",
									"pm.test(\"Данные в ответе должны соответствовать данным в запросе\", function () {\r",
									"    pm.expect(target.message).to.contain(\"Validation failed\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "PATCH",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{request_body}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/users/{{uid}}/events/{{eid}}/comments/{{cid}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"users",
								"{{uid}}",
								"events",
								"{{eid}}",
								"comments",
								"{{cid}}"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"API = class {",
					"    constructor(postman, verbose = false, baseUrl = \"http://localhost:8080\") {",
					"        this.baseUrl = baseUrl;",
					"        this.pm = postman;",
					"        this._verbose = verbose;",
					"    }",
					"",
					"    async addUser(user, verbose=null) {",
					"        return this.post(\"/admin/users\", user, \"Ошибка при добавлении нового пользователя: \", verbose);",
					"    }",
					"",
					"    async addCategory(category, verbose=null) {",
					"        return this.post(\"/admin/categories\", category, \"Ошибка при добавлении новой категории: \", verbose);",
					"    }",
					"",
					"    async addEvent(userId, event, verbose=null) {",
					"        return this.post(\"/users/\" + userId + \"/events\", event, \"Ошибка при добавлении нового события: \", verbose);",
					"    }",
					"",
					"    async addCompilation(compilation, verbose=null) {",
					"        return this.post(\"/admin/compilations\", compilation, \"Ошибка при добавлении новой подборки: \", verbose);",
					"    }",
					"",
					"    async addComment(userId, eventId, comment, verbose=null) {",
					"        return this.post(\"/users/\" + userId + \"/events/\" + eventId + \"/comments\", comment, \"Ошибка при добавлении нового комментария: \", verbose);",
					"    }",
					"",
					"    async publishParticipationRequest(eventId, userId, verbose=null) {",
					"        return this.post('/users/' + userId + '/requests?eventId=' + eventId, null, \"Ошибка при добавлении нового запроса на участие в событии\", verbose);",
					"    }",
					"",
					"    async publishEvent(eventId, verbose=null) {",
					"        return this.patch('/admin/events/' + eventId, {stateAction: \"PUBLISH_EVENT\"}, \"Ошибка при публикации события\", verbose);",
					"    }",
					"    ",
					"    async rejectEvent(eventId, verbose=null) {",
					"        return this.patch('/admin/events/' + eventId, {stateAction: \"REJECT_EVENT\"}, \"Ошибка при отмене события\", verbose);",
					"    }",
					"",
					"    async acceptParticipationRequest(eventId, userId, reqId, verbose=null) {",
					"        return this.patch('/users/' + userId + '/events/' + eventId + '/requests/', {requestIds:[reqId], status: \"CONFIRMED\"}, \"Ошибка при принятии заявки на участие в событии\", verbose);",
					"    }",
					"",
					"    async findCategory(catId, verbose=null) {",
					"        return this.get('/categories/' + catId, null, \"Ошибка при поиске категории по id\", verbose);",
					"    }",
					"",
					"    async findCompilation(compId, verbose=null) {",
					"        return this.get('/compilations/' + compId, null, \"Ошибка при поиске подборки по id\", verbose);",
					"    }",
					"",
					"    async findUser(userId, verbose=null) {",
					"        return this.get('/admin/users?ids=' + userId, null, \"Ошибка при поиске пользователя по id\", verbose);",
					"    }",
					"",
					"    async post(path, body, errorText = \"Ошибка при выполнении post-запроса: \", verbose=null) {",
					"        return this.sendRequest(\"POST\", path, body, errorText, verbose);",
					"    }",
					"",
					"    async patch(path, body = null, errorText = \"Ошибка при выполнении patch-запроса: \", verbose=null) {",
					"        return this.sendRequest(\"PATCH\", path, body, errorText, verbose);",
					"    }",
					"",
					"    async get(path, body = null, errorText = \"Ошибка при выполнении get-запроса: \", verbose=null) {",
					"        return this.sendRequest(\"GET\", path, body, errorText, verbose);",
					"    }",
					"",
					"",
					"    async sendRequest(method, path, body=null, errorText = \"Ошибка при выполнении запроса: \", verbose=null) {",
					"        return new Promise((resolve, reject) => {",
					"            verbose = verbose == null ? this._verbose : verbose;",
					"",
					"            const request = {",
					"                url: this.baseUrl + path,",
					"                method: method,",
					"                body: body == null ? \"\" : JSON.stringify(body),",
					"                header: { \"Content-Type\": \"application/json\" },",
					"            };",
					"",
					"            if(verbose) {",
					"                console.log(\"Отправляю запрос: \", request);",
					"            }",
					"",
					"            try {",
					"                this.pm.sendRequest(request, (error, response) => {",
					"                    if(error || (response.code >= 400 && response.code <= 599)) {",
					"                        let err = error ? error : JSON.stringify(response.json());",
					"                        console.error(\"При выполнении запроса к серверу возникла ошика.\\n\", err,",
					"                             \"\\nДля отладки проблемы повторите такой же запрос к вашей программе \" + ",
					"                             \"на локальном компьютере. Данные запроса:\\n\", JSON.stringify(request));",
					"",
					"                        reject(new Error(errorText + err));",
					"                    }",
					"",
					"                    if(verbose) {",
					"                        console.log(\"Результат обработки запроса: код состояния - \", response.code, \", тело: \", response.json());",
					"                    }",
					"",
					"                    resolve(response.json());",
					"                });",
					"            } catch(err) {",
					"                if(verbose) {",
					"                    console.error(errorText, err);",
					"                }",
					"                return Promise.reject(err);",
					"            }",
					"        });",
					"    }",
					"};",
					"",
					"RandomUtils = class {",
					"    constructor() {}",
					"",
					"    delay(time) {",
					"        return new Promise(resolve => setTimeout(resolve, time));",
					"    }",
					"",
					"",
					"    getComment() {",
					"        return {",
					"            text: pm.variables.replaceIn('{{$randomLoremSentence}}')",
					"        };",
					"    }",
					"",
					"    getUser() {",
					"        return {",
					"            name: pm.variables.replaceIn('{{$randomFullName}}'),",
					"            email: pm.variables.replaceIn('{{$randomEmail}}')",
					"        };",
					"    }",
					"",
					"    getCategory() {",
					"        return {",
					"            name: pm.variables.replaceIn('{{$randomWord}}') + Math.floor(Math.random() * 100).toString()",
					"        };",
					"    }",
					"",
					"    getEvent(categoryId) {",
					"        return {",
					"            annotation: pm.variables.replaceIn('{{$randomLoremParagraph}}'),",
					"            category: categoryId,",
					"            description: pm.variables.replaceIn('{{$randomLoremParagraphs}}'),",
					"            eventDate: this.getFutureDateTime(),",
					"            location: {",
					"                lat: parseFloat(pm.variables.replaceIn('{{$randomLatitude}}')),",
					"                lon: parseFloat(pm.variables.replaceIn('{{$randomLongitude}}')),",
					"            },",
					"            paid: pm.variables.replaceIn('{{$randomBoolean}}'),",
					"            participantLimit: pm.variables.replaceIn('{{$randomInt}}'),",
					"            requestModeration: pm.variables.replaceIn('{{$randomBoolean}}'),",
					"            title: pm.variables.replaceIn('{{$randomLoremSentence}}'),",
					"        }",
					"    }",
					"",
					"    getCompilation(...eventIds) {",
					"        return {",
					"            title: pm.variables.replaceIn('{{$randomLoremSentence}}'),",
					"            pinned: pm.variables.replaceIn('{{$randomBoolean}}'),",
					"            events: eventIds",
					"        };",
					"    }",
					"",
					"    getFutureDateTime(hourShift = 5, minuteShift=0, yearShift=0) {",
					"        let moment = require('moment');",
					"",
					"        let m = moment();",
					"        m.add(hourShift, 'hour');",
					"        m.add(minuteShift, 'minute');",
					"        m.add(yearShift, 'year');",
					"",
					"        return m.format('YYYY-MM-DD HH:mm:ss');",
					"    }",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "baseUrl",
			"value": "http://localhost:8080",
			"type": "string"
		},
		{
			"key": "eid",
			"value": "1",
			"type": "string"
		},
		{
			"key": "uid",
			"value": "1",
			"type": "string"
		},
		{
			"key": "request_body",
			"value": "",
			"type": "string"
		},
		{
			"key": "comment",
			"value": "",
			"type": "string"
		},
		{
			"key": "cid",
			"value": "1",
			"type": "string"
		}
	]
}